using System;
using System.Windows;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;

namespace simulation
{
    class CollisionMap
    {
        int[,] collisionArray;
        int tileSize;
        int air = 0;
        int squareCollision = 1;
        int _45degSlopeNW = 2;
        int _45degSlopeNE = 3;
        int _45degSlopeSW;
        int _45degSlopeSE;
        int _60degSlopeNW1 = 4;
        int _60degSlopeNW2 = 5;
        int _60degSlopeNE1 = 6;
        int _60degSlopeNE2 = 7;

        public CollisionMap(int[,] collisionarray, int tilesize)
        {
            collisionArray = collisionarray;
            tileSize = tilesize;
        }
        public static Boolean isCollision(CollisionPoly poly1, CollisionPoly poly2)
        {
            Vector2 direction = new Vector2();
            List<Vector2> simplex = new List<Vector2>();
            while (true)
            {
                switch (simplex.Count)
                {
                    case 0:
                        //direction in the direction of separation
                        direction = Vector2.Subtract(poly1.center(), poly2.center());
                        break;
                    case 1:
                        //direction opposite direction of separation
                        direction = Vector2.Multiply(direction, -1);
                        break;
                    case 2:
                        //direction orthogonal to the line segment generated by first two points and also 
                        direction = tripleCrossProd(Vector2.Subtract(simplex[1], simplex[0]), Vector2.Multiply(simplex[0], -1), Vector2.Subtract(simplex[1], simplex[0]));
                        break;
                    case 3:

                        Vector2 side1 = Vector2.Subtract(simplex[1], simplex[2]);
                        Vector2 side2 = Vector2.Subtract(simplex[0], simplex[2]);
                        //vector orthogonal to the 2nd line segment generated (vertex 2 -> vertex 1)
                        Vector2 orthogonal1 = tripleCrossProd(side2, side1, side1);
                        //vector orthogonal to third line segment generated (vertex 3 -> vertex 1)
                        Vector2 orthogonal2 = tripleCrossProd(side1, side2, side2);
                        if (Vector2.Dot(orthogonal1, Vector2.Multiply(simplex[2], -1)) > 0)
                        {
                            direction = orthogonal1;
                            simplex.RemoveAt(0);
                        }
                        else if (Vector2.Dot(orthogonal2, Vector2.Multiply(simplex[2], -1)) > 0)
                        {
                            direction = orthogonal2;
                            simplex.RemoveAt(1);
                        }
                        else
                        {
                            return true;
                        }
                        break;
                }
                Vector2 nextVert = Vector2.Subtract(poly1.supportFunction(direction), poly2.supportFunction(Vector2.Multiply(direction, -1)));
                if (Vector2.Dot(direction, nextVert) > 0)
                {
                    simplex.Add(nextVert);
                }
                else
                {
                    return false;
                }
            }
        }
        public static calculateIntersection(Player player, Vector2 finalPosition) { }
        public static Vector2 tripleCrossProd(Vector2 firstvector, Vector2 secondvector, Vector2 thirdvector)
        {
            Vector3 vector1 = new Vector3(firstvector.X, firstvector.Y, 0);
            Vector3 vector2 = new Vector3(secondvector.X, secondvector.Y, 0);
            Vector3 vector3 = new Vector3(thirdvector.X, thirdvector.Y, 0);
            Vector3 output = Vector3.Cross(Vector3.Cross(vector1, vector2), vector3);
            return new Vector2(output.X, output.Y);
        }
        public Vector2[] broadPhase(Vector2 initialPos, Vector2 finalPos, Vector2 dim)
        {
            Vector2[] broadPhaseBoxCorners = new Vector2[2];
            broadPhaseBoxCorners[0] = Vector2.Divide(initialPos,tileSize);
            broadPhaseBoxCorners[1] = Vector2.Divide(finalPos + dim, tileSize);
            return broadPhaseBoxCorners;
        }
        public Vector2 calculateCollisions(Vector2 velocity, Vector2 finalPos, Player player)
        {
            Vector2[] bBox = broadPhase(player.Position, finalPos, new Vector2(player.Height, player.Width));
            Vector2[] finalPosVerts = new Vector2[4];
            for()
            CollisionPoly playerPoly = new CollisionPoly();
            int currentTile;
            for (int i = (int)Math.Floor(bBox[0].X); i < (int)Math.Ceiling(bBox[1].X); i++)
            {
                for (int j = (int)Math.Floor(bBox[0].Y); j < (int)Math.Ceiling(bBox[1].Y); j++)
                {
                    currentTile = collisionArray[i, j];
                    if (currentTile == 0)
                    {
                        return velocity;
                    }
                    else if (currentTile == 1)
                    {
                        if (isCollision(playerPoly, new CollisionPoly(new Vector2[] { new Vector2(i * tileSize, j * tileSize), new Vector2((i + 1) * tileSize, j * tileSize), new Vector2(i * tileSize, (j + 1) * tileSize), new Vector2((i + 1) * tileSize, (j + 1) * tileSize) })))
                        {

                        }
                    }
                }
            }
        }
        
       
    }
}
